// C++ programming
#include <iostream>   >>> #include is preprocessor, <iostream> is a library
using namespace std;  >>> using the standard namespace

int main() {          >>> overloading involves using the same function name with different paramaters (signature- does NOT include return type). Header of function is prototype
  double radius;      >>> assigning a variable as double, could initialize (radius = ...) in the same step
  double area;

  cout << "Enter a radius: ";
  cin >> radius;

  area = radius*radius*3.14159;
  // End signs are only when variable is being used
  cout << "The area is" << area << endl;

  return 0;
}

if()
{
for more than one line, brackets are needed
}
short-circuit. if using "and" as an operator, and the first statement is false, then it will not evaluate the others and instead mark it as false.
Ex. #include <iostream>
using namespace std;

int main()
{
  int number;
  cout << "Enter an integer: ";
  cin >> number;

  if (number % 2 == 0 && number % 3 == 0)
    cout << number << " is divisible by 2 and 3." << endl;

  if (number % 2 == 0 || number % 3 == 0)
    cout << number << " is divisible by 2 or 3." << endl;

  if ((number % 2 == 0 || number % 3 == 0) &&
       !(number % 2 == 0 && number % 3 == 0))
    cout << number << " divisible by 2 or 3, but not both." << endl;

  return(0);
}
Ternary operator: 
if (x > 0)
y = 1
else
y = -1;
is equivalent to
y = (x > 0) ? 1 : -1;
(booleanExpression) ? expression1 : expression2

// Function prototype- can declare a function (function header, function declaration)
int max(int num1, int num2);
double max(double num1, double num2);
// Then int main()
// If used, functions need to be written in the order they are called/used

// Inline functions- before execution, at compiling. Decreases cost and execution time
// ex. inline void f(int month, int year) 
{
  cout << "month is " << month << endl;
  cout << "year is " << year << endl;
}

// int main()
{
  int month = 10, year = 2008;
  f(month, year);  // Invoke inline function
  f(9, 2010); // Invoke f with month 9 and year 2010

  return 0;
} 

// Scope- from the declaration to the end of the block (end bracket)

// Global variables- outside all functions, can be used in all functions (default value == 0)
// Local variables- inside a function, can only be used in that function

// Static local variables- after a function completes execution, all its local variables are destroyed. Static local variables retain their value for the lifetime of the program
ex. static int x = 1;
    int y = 1; // y will not be retained, x will.
    // static variables only work with t1() or t2()?

// Reference variables- an alias for an already existing variable
ex. int count = 1;
    int& r = count;  // r is a reference variable to count.
    r++;
    count = 10;  // count and r are both 10 now.
// Give & for acutal paramaters or arguments
// const. int- cannot change the value

// Recursion- a function that calls itself
One or more base cases- one or more base cases are used to stop encursion (base case and recursive case. goes on for as long as base case is true)
Break it into subproblems- if it resembles the original problem, apply the same approach.

// Factorial functions, permutations, base cases and recursive cases
5! = 5 * 4!
4! = 4 * 3!
3! = 3 * 2!
2! = 2 * 1!
11! = 1
// Example output, longer code
S = abccba

// Recursive Binary Search- all numbers should be in assorted form, ascending (or descendending). 3 cases, if the key is less than, greater than, or equal to the middle element.
low = 0
mid = (low + high) // 2
high = 12
int binarySearch(const int list[], int key, int size) {   // C++ has no built in function for size of array, so will have to declare as a parameter
  int low = 0;
  int high = size - 1;
  return binarySearch(list, key, low, high);
}
ex. int i = binarySearch(list[], 2, 13);   // Will search for 2 in an array of size 13

// How to access last element- list[list.size() -1] OR list[12] if size is 13


// ex. array- int array[] = {2, 4, 7, 10, 11};  // size of array will be the number of elements in the brackets

// Quiz on functions and recursion on Monday

// Pointer variables (pointers)- hold memory addresses as their values, which in turn contains a specific type of declaration
// can use the dereference operator (*) to access the actual value at a specific memory location
// the ampersand symbol (&) is called the address operator when placed in front of a variable. returns the variable's address (&count = address of count)
ex. int* ptr; // want to create a pointer type variablethat points to an integer
char* ptr; // q will hold address of a character