// C++ programming
#include <iostream>   >>> #include is preprocessor, <iostream> is a library
using namespace std;  >>> using the standard namespace

int main() {          >>> overloading involves using the same function name with different paramaters (signature- does NOT include return type). Header of function is prototype
  double radius;      >>> assigning a variable as double, could initialize (radius = ...) in the same step
  double area;

  cout << "Enter a radius: ";
  cin >> radius;

  area = radius*radius*3.14159;
  // End signs are only when variable is being used
  cout << "The area is" << area << endl;

  return 0;
}

if()
{
for more than one line, brackets are needed
}
short-circuit. if using "and" as an operator, and the first statement is false, then it will not evaluate the others and instead mark it as false.
Ex. #include <iostream>
using namespace std;

int main()
{
  int number;
  cout << "Enter an integer: ";
  cin >> number;

  if (number % 2 == 0 && number % 3 == 0)
    cout << number << " is divisible by 2 and 3." << endl;

  if (number % 2 == 0 || number % 3 == 0)
    cout << number << " is divisible by 2 or 3." << endl;

  if ((number % 2 == 0 || number % 3 == 0) &&
       !(number % 2 == 0 && number % 3 == 0))
    cout << number << " divisible by 2 or 3, but not both." << endl;

  return(0);
}
Ternary operator: 
if (x > 0)
y = 1
else
y = -1;
is equivalent to
y = (x > 0) ? 1 : -1;
(booleanExpression) ? expression1 : expression2

// Function prototype- can declare a function (function header, function declaration)
int max(int num1, int num2);
double max(double num1, double num2);
// Then int main()
// If used, functions need to be written in the order they are called/used

// Inline functions- before execution, at compiling. Decreases cost and execution time
// ex. inline void f(int month, int year) 
{
  cout << "month is " << month << endl;
  cout << "year is " << year << endl;
}

// int main()
{
  int month = 10, year = 2008;
  f(month, year);  // Invoke inline function
  f(9, 2010); // Invoke f with month 9 and year 2010

  return 0;
} 

// Scope- from the declaration to the end of the block (end bracket)

// Global variables- outside all functions, can be used in all functions (default value == 0)
// Local variables- inside a function, can only be used in that function

// Static local variables- after a function completes execution, all its local variables are destroyed. Static local variables retain their value for the lifetime of the program
ex. static int x = 1;
    int y = 1; // y will not be retained, x will.
    // static variables only work with t1() or t2()?

// Reference variables- an alias for an already existing variable
ex. int count = 1;
    int& r = count;  // r is a reference variable to count.
    r++;
    count = 10;  // count and r are both 10 now.
// Give & for actual paramaters or arguments
// const int- cannot change the value

// Recursion- a function that calls itself
One or more base cases- one or more base cases are used to stop encursion (base case and recursive case. goes on for as long as base case is true)
Break it into subproblems- if it resembles the original problem, apply the same approach.

// Factorial functions, permutations, base cases and recursive cases
5! = 5 * 4!
4! = 4 * 3!
3! = 3 * 2!
2! = 2 * 1!
11! = 1
// Example output, longer code
S = abccba

// Recursive Binary Search- all numbers should be in assorted form, ascending (or descendending). 3 cases, if the key is less than, greater than, or equal to the middle element.
low = 0
mid = (low + high) // 2
high = 12
int binarySearch(const int list[], int key, int size) {   // C++ has no built in function for size of array, so will have to declare as a parameter
  int low = 0;
  int high = size - 1;
  return binarySearch(list, key, low, high);
}
ex. int i = binarySearch(list[], 2, 13);   // Will search for 2 in an array of size 13

// How to access last element- list[list.size() -1] OR list[12] if size is 13


// ex. array- int array[] = {2, 4, 7, 10, 11};  // size of array will be the number of elements in the brackets

// Quiz on functions and recursion on Monday

// Pointer variables (pointers)- hold memory addresses as their values, which in turn contains a specific type of declaration
// can use the dereference operator (*) to access the actual value at a specific memory location
// the ampersand symbol (&) is called the address operator when placed in front of a variable. returns the variable's address (&count = address of count)
ex. int* ptr; // want to create a pointer type variable that points to an integer
char* ptr; // q will hold address of a character (3000, 2000, the location in memory of the variable)
int x;
x = 12;
int* ptr;
ptr = &x;
cout << *ptr;  // unary operator is the dereference (tells it to print the value at that memory address *)
*ptr = 5;  // changes the value of x to 5 (could be achieved by x = 5;)
ex.    // Make sure the process is understandable and the outcome is predictable to you
char ch;
ch = "A";
char* q;
q = &ch;  // stores address in pointer variable q (ampersand sign points to address)
*q = "Z"; // changes the value of ch to Z, not q to Z (q maintains the address of ch)
char* p;
p = q;  // p now points to 4000 (the address/value of q)
// If *p2 = *p1, value pointed to by p2 = value pointed to by p1

// Typedef- a pointer variable with the exisiting type, different name
ex. typedef int integer;
    typedef int* intPointer;  // can use intPointer** p1, p2;
    double* const pValue = &radius;  // pValue is a const pointer to a double value
  
// Arrays and Pointers
void printArray(const int* list, int size) {
  for (int i = 0; i < size; i++)
  cout << list[i] << endl;
}
int main() {
  int list[6] = {11, 12, 13, 14, 15, 16};  // this is an array with 6 values
  int* p = reverse(list, 6);
  printArray(p, 6);
  return 0;
}

// Function call and pointer variables
void f(int* p1, int* &p2)  // this is same as below
typedef int* intPointer;
void f(intPointer p1, intPointer& p2)  // same as above. Here, p1 is pass-by-value and p2 is pass-by-reference

// Function to swap list i with list j
int* reverse(int* list, int size) {
  for(int i = 0, j = size - 1; i < j; i++, j--)
  {
    int temp = list[j];
    list[j] = list[i];
    list[i] = temp;
  }
  return list;
}

// Array- collectio of the same data types. Can access each element using an index. Arrays can have 10 elements, no more.
datatype arrayName[arraySize]; // can initialize as well(= {value0, value1... valuek};)
arrayName[place] = value;

// Passing array to functions- can pass one value, or can pass the whole array. Should also pass the size of the array as a parameter.
// Passing an array variable means the starting address of the array is passed to the formal parameter BY VALUE
ex. void printArray(int list[], int arraySize);
int main() {
  int numbers[6] = {1, 4, 3, 6, 8, 9};
  rintArray(numbers, 6);  // passing the whole array
}
void printArray(int list[], int arraySize) {
  for (int i = 0; i < arraySize; i++)
    cout << list[i] << " ";
}

// Const variables- a readable, not changeable variable
// Use const when you do not want a function to change the value of an argument
// newList is the reversal of list
void reverse(const int list[], int newList[], int size) {
  for (int i = 0, j = size - 1; i < size; i++, j--) {
    newList[j] = list[i];
  }
}
void printArray(const int list[], int size) {
  for (int i = 0; i < size; i++)
    cout << list[i] << " ";
}
int main() {
  const int SIZE = 6;
  int list[] = {1, 2, 3, 4, 5, 6};
  int newList[SIZE];
  reverse(list, newList, SIZE);
  cout << "The original array: ";
  printArray(list, SIZE);
  cout << endl;
  cout << "The reversed array: ";
  printArray(newList, SIZE);
  cout << endl;
  return 0;
}
// Cannot return an array from a function
// Can circumvent this by passing two array arguments in the function
